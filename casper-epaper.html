<!--
  - Copyright (c) 2014-2016 Neto Ranito & Seabra LDA. All rights reserved.
  -
  - This file is part of casper-epaper.
  -
  - casper-epaper is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-epaper  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-epaper.  If not, see <http://www.gnu.org/licenses/>.
  -
 -->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/iron-icons.html">
<link rel="import" href="../paper-card/paper-card.html">
<link rel="import" href="../casper-epaper/casper-epaper-imports.html">
<link rel="import" href="../casper-epaper/casper-epaper-input.html">
<link rel="import" href="../casper-epaper/casper-epaper-tooltip.html">
<link rel="import" href="../casper-epaper/casper-epaper-tooltip.html">
<link rel="import" href="../casper-epaper/casper-epaper-servertip-helper.html">
<!--
  `<awesome-sauce>` injects a healthy dose of awesome into your page.

   In typical use, just slap some `<awesome-sauce>` at the top of your body:

       <body>
         <awesome-sauce></awesome-sauce>

   Wham! It's all awesome now!
-->
<dom-module id="casper-epaper">
  <template>
    <style>
      :host {
        display: block;
      }

      #canvas {
        outline: none;
      }

      iron-icon {
        position: absolute;
        display: inline-block;
        cursor: pointer;
        padding: 1px;
        margin: 0px;
        width: 24px;
        height: 24px;
        fill: var(--dark-primary-color);
      }

      #line_add_button:hover {
        fill: var(--primary-color);
      }

      #line_del_button:hover {
        fill: red;
      }

    </style>
    <paper-card width="[[width]]" height="[[height]]" >
      <canvas id="canvas" width="[[width]]" height="[[height]]"></canvas>
      <casper-epaper-input id="input"></casper-epaper-input>
      <casper-epaper-tooltip id="tooltip"></casper-epaper-tooltip>
      <casper-epaper-servertip-helper id="servertip"></casper-epaper-servertip-helper>
      <iron-icon id="line_add_button" on-tap="_addDocumentLine" icon="add-circle"/></iron-icon>
      <iron-icon id="line_del_button" on-tap="_removeDocumentLine" icon="remove-circle"></iron-icon>
    </paper-card>
  </template>

  <script>

    EPaperSocket_Initialize(window);

    Polymer({
      is: 'casper-epaper',
      properties: {
        /** component width in px */
        width: {
          type: Number,
          value: 595
        },
        /** component height in px */
        height: {
          type: Number,
          value: 842
        },
        /** object that specifies the document being displayed/edited */
        document: {
          type: Object,
          observer: '_document_changed'
        },
        /** websocket URL */
        url: {
          type: String,
          value: undefined
        },
        /** websocket port number, defaults to current page port */
        port: {
          type: String,
          value: undefined
        }
      },

      /*
       * Constants
       */
      _BTN_SIZE:        24,  // Size is in pixels not pt
      _KAPPA:           .5522848,
      _BOLD_MASK:       0x01,
      _ITALIC_MASK:     0x02,
      _UNDERLINE_MASK:  0x04,
      _STRIKEOUT_MASK:  0x08,
      _BOLD_INDEX:      0,
      _ITALIC_INDEX:    1,
      _SIZE_INDEX:      2,
      _FONT_NAME_INDEX: 4,

      ready: function () {
        this._calculate_attribute_defaults();

        this._socket            = new EPaperSocket(this, this.url, this.port, this.uri);
        this._listener          = undefined;
        this._canvas            = this.$.canvas;
        this._canvas_width      = this._canvas.width;
        this._canvas_height     = this._canvas.height;
        this.$.input._epaper    = this;
        this._scroll_container_ = undefined;  // TODO hack
        this._ctx               = this._canvas.getContext('2d', {alpha: false});
        this._initial_pointer   = this._canvas.style.cursor;
        this._ctx.globalCompositeOperation = 'copy';
        this._page_count        = 0;
        this._page_number       = 1;
        this._message           = '';
        this._r_idx             = 0.0;
        this._bands             = undefined;
        this._document_id       = undefined;
        this._images            = {};
        this._widget_under_mice = undefined;
        this._focused_band_id   = undefined;
        this._redraw_timer_key  = '_epaper_redraw_timer_key';
        this._reset_render_state();
        this._reset_command_data();

        this._page_width  = 595.0;
        this._page_height = 842.0;
        this._grid_major  = 0.0;
        this._grid_minor  = 0.0;

        this._is_socket_open = false;

        // Variables to save the object context
        this._saved_idx         = 0.0;
        this._saved_draw_string = '';
        this._inputBoxDrawString = undefined;

        this._setup_pixel_ratio();

        this._edition = false;

        this._canvas.contentEditable = false;

        this._background_color  = '#FFFFFF';
        this._normal_background = '#FFFFFF';
        if ( this._master_doc_right_margin !== undefined ) {
          this._right_margin = this._master_doc_right_margin;
        }

        // ... clear the page before we start ...
        this._setup_scale();

        // ... FOUT Mitigation @TODO proper FOUT mitigation ...
        var styles    = ['', 'bold ', 'italic ', 'italic bold '];
        var y = 175;
        this._ctx.save();
        this._ctx.fillStyle = "#F0F0F0"
        this._ctx.textAlign="center";
        this._font_spec[this._SIZE_INDEX] = 20;
        for ( var i = 0; i < styles.length; i++ ) {
          this._font_spec[this._BOLD_INDEX] = styles[i];
          this._ctx.font = this._font_spec.join('');
          this._ctx.fillText("Powered by CASPER ePaper", this._canvas.width / 2, y);
          y += 35;
        }
        this._ctx.restore();
      },

      attached: function () {
        this.$.tooltip.positionTarget = this.$.input;
        this.$.tooltip.fitInto = this.$.canvas;
        this.$.servertip.epaper = this;
        this.$.servertip.input = this.$.input;
        this.listen(this.$.canvas, 'mousemove', '_moveHandler');
        this.listen(this.$.canvas, 'mousedown', '_mouseDownHandler');
        this.listen(this.$.canvas, 'mouseup'  , '_mouseUpHandler');
        this._deactivateLineContextMenu();
      },

      detached: function () {
        this.unlisten(this.$.canvas, 'mousemove', '_moveHandler');
        this.unlisten(this.$.canvas, 'mousedown', '_mouseDownHandler');
        this.unlisten(this.$.canvas, 'mouseup'  , '_mouseUpHandler');
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                                  ~~~ Public API ~~~                                   */
      /*                                                                                       */
      /*****************************************************************************************/

      _validate_response: function (a_expected_response, a_response) {
        var expected_start;

        expected_start = 'S:ok:' + a_expected_response;
        if ( match = a_response.match(/^S:failure:.*?:(.*)/) ) {
          return new Error(JSON.parse(match[1]));
        } else if ( a_response.indexOf('S:error:') === 0 || a_response.indexOf('S:exception:') === 0 ) {
          return new Error(a_response);
        } else if (a_response.indexOf(expected_start) === 0 ) {
          return a_response.substring(expected_start.length + 1);
        }
      },

      /**
       * Open server document
       *
       * @param a_document an object that specifies the layout and data of the document
       */
      open: function (a_document) {

        var prepare_open_command = function (a_epaper, a_document) {
          self = a_epaper;
          self._command = {
            path:         a_document.path,
            params:       a_document.params,
            jrxml:        a_document.jrxml,
            prefix:       a_document.prefix       || 'https://localhost/',
            locale:       a_document.locale       || 'pt_PT',
            schema:       a_document.schema       || '',
            table_prefix: a_document.table_prefix || '',
            edit:         a_document.edit         || false,
            subdocument:  a_document.subdocument  || false,
          };
          self._edition = self._command.edit;
        };

        // Promise to open the report layout in case it not loaded yet
        var open_document = function (a_epaper) {
          return new Promise(function (a_resolve, a_reject) {
            self = a_epaper;
            //self._make_widgets_invisible();

            if ( self._jrxml === self._command.jrxml && self._locale === self._command.locale && self._subdocument === self._command.subdocument ) {
              return a_resolve(self);
            }
            self.send_command('document open "' + self._command.jrxml + '","' + self._command.locale + '",' + self._command.subdocument + ',false;', function (a_response) {
              var response = self._validate_response('open', a_response);
              if ( response instanceof Error ) {
                a_reject(response);
              } else {

                self._message     = response;
                self._r_idx       = 0;
                self._document_id = self._getDouble();
                self._page_width  = self._getDouble();
                self._page_height = self._getDouble();
                if ( isNaN(self._page_height) ) {
                  self._page_height = 4000;
                }
                self._right_margin = self._getDouble();
                self._jrxml        = self._command.jrxml;
                self._locale       = self._command.locale;
                self._subdocument  = self._command.subdocument;
                a_resolve(self);
              }
            });
          });
        };

        // Promise to configure the JSON API in case it's config has changed
        var configure_api = function (a_epaper) {
          return new Promise(function (a_resolve, a_reject) {
            self = a_epaper;

            if ( self._prefix === self._command.prefix && self._schema === self._command.schema && self._table_prefix === self._command.table_prefix ) {
              return a_resolve(self);
            }

            self.send_command('document config json_api "' + self._command.prefix + '","' + self._command.schema + '","' + self._command.table_prefix + '";', function (a_response) {
              var response = self._validate_response('json_api', a_response);

              if ( response instanceof Error ) {
                a_reject(response);
              } else {
                self._prefix       = self._command.prefix;
                self._schema       = self._command.schema;
                self._table_prefix = self._command.table_prefix;
                a_resolve(self);
              }
            });
          });
        };

        // Promise to load the document data
        var load_document = function (a_epaper) {
          return new Promise(function (a_resolve, a_reject) {
            self = a_epaper;

            if ( self._edition == false ) {
              //self._input_box._enabled = false;
            }
            self.send_command('document load ' + '"' + self._command.path + '"' + (self._command.params !== undefined ? ',"' + self._command.params + '"' : '') + ','
                              + self._sx.toFixed(4) + ',' + self._sy.toFixed(4) + ',' + self._subdocument + ',' + self._edition + ';', function (a_response) {
              var response = self._validate_response('load', a_response);
              if ( response instanceof Error ) {
                a_reject(response);
              } else {
                self._path   = self._command.path;
                self._params = self._command.params;
                a_resolve(self);
              }
            });
          });
        };

        this.$.input.hideOverlays();

        // ... perform the command sequence ...
        prepare_open_command(this, a_document);
        open_document(this)
          .then(configure_api)
          .then(load_document)
          .catch(function(a_error) {
            alert("Paper error " + a_error);
          });
      },

      reconnect: function ()Â {
        this.clear();
        this._socket.connect();
      },

      set_listener: function (a_listener) {
        this._listener = a_listener;
      },

      close_document: function (a_success_handler) {
        //this._make_widgets_invisible();
        this.$.input.hideOverlays();
        this.call_rpc('close', 'document close "' + this._document_id + '";', function(a_epaper, a_message) {
            var expected_response = 'S:ok:close:' + a_epaper._document_id;
            if ( a_message.indexOf(expected_response) === 0 ) {
              if ( a_message.length > expected_response.length ) {
                a_epaper._document_id = a_message.substring(expected_response.length + 1).replace('\n', '');
              } else {
                a_epaper._document_id = undefined;
              }
            }
            if ( undefined !== a_success_handler ) {
              a_success_handler();
            }
          }
        );
      },

      reload_document: function (a_success_handler) {
        this.call_rpc('reload', 'document reload;', function(a_epaper, a_message) {
            if ( undefined !== a_success_handler ) {
              a_success_handler(a_message.substring('S:ok:reload:'.length));
            }
          }
        );
      },

      document_focus_row: function (a_index, a_success_handler) {
        this.call_rpc('focused row', 'document set focused row ' + a_index + ';', function(a_epaper, a_message) {
            if ( undefined !== a_success_handler ) {
              a_success_handler(a_message.substring('S:ok:focused row:'.length));
            }
          }
        );
      },

      call_rpc: function (a_invoke_id, a_command, a_success_handler, a_failure_handler) {

        a_failure_handler = a_failure_handler || function (a_epaper, a_message) {
          if ( a_epaper._listener !== undefined ) {
            a_epaper._listener.on_error(a_message);
          } else {
            alert(a_message);
          }
        }

        this.send_command(a_command, function (a_message) {
          if ( a_message.indexOf('S:error:') === 0 || a_message.indexOf('S:exception:') === 0 ) {
            a_failure_handler(this, a_message);
            return;
          }
          if ( a_message.indexOf('S:ok:' + a_invoke_id) === 0 ) {
            a_success_handler(this, a_message);
          }

        });
      },

      _document_changed: function (a_document) {
        if (this._socket === undefined || a_document == null) return; // MARTELADA
        console.log('And then document wos set' + document);
        this.open(a_document);
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                      ~~~ Constructor and intialization ~~~                            */
      /*                                                                                       */
      /*****************************************************************************************/

      /**
       * @brief Assing defaults to undefined component attributes
       */
      _calculate_attribute_defaults: function () {
        if ( this.url === undefined ) {
          if ( window.location.protocol === 'https:' ) {
            this.url = 'wss://' + window.location.hostname;
          } else {
            this.url = 'ws://' + window.location.hostname;
          }
        }
        this.port = this.port || window.location.port;
        this.uri  = this.uri  || 'epaper';
      },

      /**
       * @brief Determine the device pixel ratio: 1 on classical displays 2 on retina/UHD displays
       */
      _setup_pixel_ratio: function () {
        var devicePixelRatio  = window.devicePixelRatio || 1;
        if (devicePixelRatio > 1.6) {
          devicePixelRatio = 2;
        } else {
          devicePixelRatio = 1;
        }
        var backingStoreRatio = this._ctx.webkitBackingStorePixelRatio ||
                                this._ctx.mozBackingStorePixelRatio ||
                                this._ctx.msBackingStorePixelRatio ||
                                this._ctx.oBackingStorePixelRatio ||
                                this._ctx.backingStorePixelRatio || 1;
        this._ratio = devicePixelRatio / backingStoreRatio;
        console.log("=== devicePixelRatio: " + devicePixelRatio + " backingStoreRatio: " + backingStoreRatio + " ratio: " + this._ratio);
      },

      /**
       * @brief Initialize the context with the same defaults used by the server
       *
       * After server and client align the render contexts the server uses diferential updates
       */
      _reset_render_state: function () {
        this._fill_color      = '#FFFFFF';
        this._text_color      = '#000000';
        this._font_spec       = ['', '', 10, 'px ', 'DejaVu Sans Condensed'];
        this._font_mask       = 0;
        this._ctx.strokeStyle = '#000000';
        this._ctx.lineWidth   = 1.0;
        this._ctx.font        = this._font_spec.join('');
      },

      /** TODO centralize here all that is needeed to init/clear the relation with server */
      _reset_command_data: function () {
        this._command      = undefined;
        this.path          = undefined;
        this.params        = undefined;
        this.jrxml         = undefined;
        this.prefix        = undefined;
        this.locale        = undefined;
        this._table_prefix = undefined;
        this._edit         = false;
        this._subdocument  = false;
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                               ~~~ Mouse handlers ~~~                                  */
      /*                                                                                       */
      /*****************************************************************************************/

      /**
       * @brief Creates the handler that listens to mouse movements
       */
      _moveHandler: function (a_event) {

        if ( this.$.servertip ) {
          this.$.servertip.onMouseMove(a_event.offsetX, a_event.offsetY);
        }
        if ( this._edition ) {
          this._update_context_menu(a_event.offsetY * this._ratio);
        }
      },

      _mouseDownHandler: function (a_event) {
        var x = a_event.offsetX * this._ratio;
        var y = a_event.offsetY * this._ratio;
      },

      _mouseUpHandler: function (a_event) {
        var x, y;

        x = (  a_event.offsetX  * this._page_width  / parseInt(this._canvas.style.width  || this._canvas.width ) );
        y = (  a_event.offsetY  * this._page_height / parseInt(this._canvas.style.height || this._canvas.height));
        this.send_command("set click " + x.toString().replace(',', '.') + ', ' + y.toString().replace(',', '.') + ';');
        if ( this._edition ) {
          this.$.input.grabFocus();
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                               ~~~ Canvas Rendering  ~~~                               */
      /*                                                                                       */
      /*****************************************************************************************/

      _paint_grid: function (a_major, a_minor) {
        var width  = this._canvas.width;
        var height = this._canvas.height;
        var x      = 0;
        var y      = 0;

        this._ctx.beginPath();
        this._ctx.strokeStyle = "#C0C0C0";
        this._ctx.lineWidth   = 0.15;
        for ( x = 0; x < width; x += a_minor ) {
          if ( (x % a_major) != 0 ) {
            this._ctx.moveTo(x,0);
            this._ctx.lineTo(x,height);
          }
        }
        for ( y = 0; y < height; y += a_minor ) {
          if ( (y % a_major) != 0 ) {
            this._ctx.moveTo(0,y);
            this._ctx.lineTo(width, y);
          }
        }
        this._ctx.stroke();

        this._ctx.beginPath();
        this._ctx.strokeStyle = "#C0C0C0";
        this._ctx.lineWidth   = 0.5;
        for ( x = 0; x < width; x += a_minor ) {
          if ( (x % a_major) == 0 ) {
            this._ctx.moveTo(x,0);
            this._ctx.lineTo(x,height);
          }
        }
        for ( y = 0; y < height; y += a_minor ) {
          if ( (y % a_major) == 0 ) {
            this._ctx.moveTo(0,y);
            this._ctx.lineTo(width, y);
          }
        }
        this._ctx.stroke();
        this._ctx.strokeStyle = "#000000";
      },

      _getDouble: function() {

        var fractional    = 0.0;
        var whole         = 0.0;
        var negative      = false;
        var parsing_whole = true;
        var divider       = 1.0;
        var current_c     = "";

        if (this._message[this._r_idx] == '-') {
          negative = true;
          this._r_idx++;
        }

        while ( true ) {
          current_c = this._message[this._r_idx++];
          switch (current_c) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              if (parsing_whole) {
                whole *= 10.0;
                whole += current_c - '0';
              } else {
                fractional *= 10.0;
                fractional += current_c - '0';
                divider    *= 10.0;
              }
              break;
            case '.':
              parsing_whole = false;
              break;
            case ',':
            case ';':
              if ( negative == false ) {
                return (whole + fractional / divider);
              } else {
                return -(whole + fractional / divider);
              }
              break;  // Not reached
            default:
              return NaN;
          }
        }
      },

      _on_paint_message: function (a_message) {
        this._r_idx   = 1;
        this._message = a_message;
        this._paint_band();
      },

      clear_page: function () {
        var saved_fill = this._ctx.fillStyle;

        this._ctx.fillStyle = this._background_color;
        this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
        if ( this._grid_major !== 0.0 ) {
          this._paint_grid(this._grid_major, this._grid_minor);
        }
        this._ctx.fillStyle = saved_fill;
      },

      /**
       * @brief Repaints the whole page using the saved bands array
       *
       * Bands are painted top to down to preserve the overlaps between bands, Z level of uppermost band is
       * always bellow the next band
       *
       * @note This function must keep the object context and canvas context unmodified
       */
      _repaint_page: function () {
        var band;

        this._reset_redraw_timer();

        //console.time("repaint_page");

        // ... save context clear the complete canvas ...
        this._save_paint_context();
        this._ctx.save();
        this.clear_page();

        // ... repaint the bands top to down to respect the painter's algorithm ...
        if ( this._bands !== undefined ) {
          for ( var i = 0; i < this._bands.length; i++ ) {

            band = this._bands[i];
            this._r_idx       = band._idx;
            this._message     = band._draw_string;
            this._paint_band();
          }
        }

        // ... now that whole page was redrawn the input box  ...
        if ( this._edition && this._inputBoxDrawString !== undefined ) {
          this._paint_string(this._inputBoxDrawString);
        }

        this._ctx.restore();
        this._restore_paint_context();

        //console.timeEnd("repaint_page");
      },

      _save_paint_context: function () {
        this._saved_idx         = this._r_idx;
        this._saved_draw_string = this._message;
      },

      _restore_paint_context: function () {
        this._r_idx           = this._saved_idx;
        this._message         = this._saved_draw_string;
      },

      _paint_string: function (a_draw_string) {
        this._message = a_draw_string;
        this._r_idx   = 0;
        this._paint_band();
      },

      /**
       * @brief the main drawing function paints a whole band
       *
       * The paint instructions are in the _message string, this string is walked using _r_idx index handling each
       * command until the end of the message
       */
      _paint_band: function () {

        var do_paint   = true;
        var option     = '';
        var option_num = 0.0;
        var x          = 0.0;
        var y          = 0.0;
        var x2         = 0.0;
        var y2         = 0.0;
        var r          = 0.0;
        var w          = 0.0;
        var h          = 0.0;
        var sx         = 0.0;
        var sy         = 0.0;
        var sh         = 0.0;
        var sw         = 0.0;
        var s          = this._ratio;
        var t1,t2,t3;

        this._reset_render_state();
        while (this._r_idx < this._message.length) {

          switch ( this._message[this._r_idx++] ) {

            /*
             * === 'Z' [d] Zap clear the screen Z, Zd clear the band array but keeps screen content;
             */
            case 'Z':

              if ( this._message[this._r_idx] === 'd' ) {
                this._reset_render_state();
                this._r_idx++;
              } else {
                this.clear_page();
              }
              this._r_idx++;
              this._bands = undefined;
              this._bands = [];
              break;

            /*
             * === 'B' Store and paint Band B<len>,<type>,<id>,<height>,<tx>,<ty>;
             * === 'b' Store Band B<len>,<type>,<id>,<height>,<tx>,<ty>;
             */
            case 'B':
            case 'b':

              option = this._message[this._r_idx - 1];
              w      = this._getDouble();
              t1     = this._message.substring(this._r_idx, this._r_idx + w); // Band type
              this._r_idx += w + 1;
              w = this._getDouble();                                          // Band ID
              t2     = this._message[this._r_idx];                           // Editable - 't' or 'f'
              this._r_idx += 2;
              h = this._getDouble();                                          // Band height
              x = this._getDouble();
              y = this._getDouble();

              // ... search for a band with same id on the stored band array ...
              var band = null;
              sx = this._binary_find_band_by_id(w);
              if ( sx !== -1 ) {
                band = this._bands[sx];
              } else {
                band = null;
              }

              // ... if the id is not found then it's a new band  ...
              if ( band === null ) {
                band = new Object;
                this._bands.push(band);
              }

              // ... store the current paint context on the band object
              band._type        = t1;
              band._id          = w;
              band.editable_    = 't' == t2 ? true : false;
              band._height      = h;
              band._tx          = x;
              band._ty          = y;
              band._idx         = this._r_idx;
              band._draw_string = this._message;

              if ( option === 'b' ) { // ... deferred painting leave the crayons in peace ...

                do_paint = false;

              } else { // ... deferred painting leave the crayons in peace ...

                do_paint = true;
                this._ctx.clearRect(0, 0, this._page_width, h);

              }
              break;

            /*
             * === 'U' Update page, repaint with bands stored on client side;
             */
            case 'U':

              if ( this._bands !== undefined && this._bands.length ) {
                this._repaint_page();
              }
              return;

            /*
             * === 'L' Simple line L<x1>,<y1>,<x2>,<y2>;
             */
            case 'L':

              if ( do_paint ) {

                x  = this._getDouble();
                y  = this._getDouble();
                x2 = this._getDouble();
                y2 = this._getDouble();

                this._ctx.beginPath();

                if ( x === x2 && this._ratio == 1 ) {

                  w = Math.round(this._ctx.lineWidth) & 0x1 ? -0.5 : 0;
                  this._ctx.moveTo(x  + w, y  + w);
                  this._ctx.lineTo(x2 + w, y2 + w);

                } else if ( y === y2 && this._ratio == 1 ) {

                  w = Math.round(this._ctx.lineWidth) & 0x1 ? -0.5 : 0;
                  this._ctx.moveTo(x  + w, y  + w)
                  this._ctx.lineTo(x2 + w, y2 + w);

                } else {

                  this._ctx.moveTo(x , y);
                  this._ctx.lineTo(x2, y2);

                }

                this._ctx.stroke();

              } else {
                this._getDouble(); this._getDouble(); this._getDouble(); this._getDouble();
              }
              break;

            /*
             * === 'R' Rectangle R[S|F|P|C]<x>,<y>,<w>,<h>
             */
            case 'R':

              switch (this._message[this._r_idx] ) {
                case 'S':
                  this._r_idx++;
                // fall trough
                default:
                  if ( do_paint ) {
                    this._ctx.strokeRect(this._getDouble(), this._getDouble(), this._getDouble(), this._getDouble());
                  } else {
                    this._getDouble(); this._getDouble(); this._getDouble(); this._getDouble()
                  }
                  break;

                case 'F':
                  this._r_idx++;
                  this._ctx.fillStyle = this._fill_color;
                  if ( do_paint ) {
                    this._ctx.fillRect(this._getDouble(), this._getDouble(), this._getDouble(), this._getDouble());
                  } else {
                    this._getDouble(); this._getDouble(); this._getDouble(); this._getDouble();
                  }
                  break;

                case 'P':
                  this._r_idx++;
                  this._ctx.fillStyle = this._fill_color;
                  if ( do_paint ) {
                    this._ctx.beginPath();
                    this._ctx.rect(this._getDouble(), this._getDouble(), this._getDouble(), this._getDouble());
                    this._ctx.fill();
                    this._ctx.stroke();
                  } else {
                    this._getDouble(); this._getDouble(); this._getDouble(); this._getDouble();
                  }
                  break;

                case 'C':
                  this._r_idx++;
                  if ( do_paint ) {
                    this._ctx.clearRect(this._getDouble(), this._getDouble(), this._getDouble(), this._getDouble());
                  } else {
                    this._getDouble(); this._getDouble(); this._getDouble(); this._getDouble();
                  }
                  break;
              }
              break;

            /*
             * === 'r'  Rounded rectangle
             *  |- 'rS' Stroke round rect          - rS<r>,<x>,<y>,<w>,<h>;
             *  |- 'rF' Fill round rect            - rF<r>,<x>,<y>,<w>,<h>;
             *  |- 'rP' Fill and stroke round rect - rP<r>,<x>,<y>,<w>,<h>;
             */
            case 'r':

              option = this._message[this._r_idx];
              switch (option) {
                case 'S':
                case 'F':
                case 'P':
                  this._r_idx++;
                  break;
                default:
                  option = 'S';
                  break;
              }
              r = this._getDouble();
              x = this._getDouble();
              y = this._getDouble();
              w = this._getDouble();
              h = this._getDouble();
              if ( do_paint ) {
                this._ctx.beginPath();
                this._ctx.moveTo( x + r, y );
                this._ctx.arcTo(  x + w , y     , x + w     , y + r     , r);
                this._ctx.arcTo(  x + w , y + h , x + w - r , y + h     , r);
                this._ctx.arcTo(  x     , y + h , x         , y + h - r , r);
                this._ctx.arcTo(  x     , y     , x + r     , y         , r);
                this._ctx.closePath();
              }
              switch(option) {
                case 'S':
                  if ( do_paint ) {
                    this._ctx.stroke();
                  }
                  break;

                case 'F':
                  this._ctx.fillStyle = this._fill_color;
                  if ( do_paint ) {
                    this._ctx.fill();
                  }
                  break;

                case 'P':
                  this._ctx.fillStyle = this._fill_color;
                  if ( do_paint ) {
                    this._ctx.fill();
                    this._ctx.stroke();
                  }
                  break;
              }
              break;

            /*
             * === 'e' Prepare   editor ep<x>,<y>,<w>,<h>;
             *  |- 'e' Start     editor es<options>,<text_x>,<text_y>,<max_width>,<length>,<text>;
             *  |- 'e' Update    editor eu<length>,<text>,<highlight_len>,<highlight>;
             *  |- 'e' Finish    editor ef<length>,<text>,<highlight_len>,<highlight>;
             *  |- 'e' Configure editor ec TODO
             *  |- 'e' Tooltip hint   eh<x>,<y>,<w>,<h>,<length>,<tooltip text>
             */
            case 'e':

              option = this._message[this._r_idx];
              this._r_idx++;
              this._ctx.save();
              if ( option === 'c') {  // Configure editor

                // ... clear the sub document variables ...
                this._sub_document_uri   = undefined;
                this._sub_document_jrxml = undefined;

                var edit_mode = this._message[this._r_idx++];
                switch ( edit_mode ) {

                case 'r': // 'r' Text, but read only
                  if ( ',' === this._message[this._r_idx] ) {
                    this._r_idx++;
                    w = this._getDouble();
                    this._sub_document_uri = this._message.substring(this._r_idx, this._r_idx + w);
                    this._r_idx += w + 1; // +1 -> ','
                    console.log("Open URI: " + this._sub_document_uri)
                    w = this._getDouble();
                    this._sub_document_jrxml = this._message.substring(this._r_idx, this._r_idx + w);
                    this._r_idx += w;
                    console.log("Open JRXML: " + this._sub_document_jrxml)
                  }
                  //this._input_box.configure_editor(edit_mode, this._sub_document_jrxml);
                  this.$.input.setMode(edit_mode);
                  this._r_idx += 1; // 't'
                  break;

                case 't':  // Text ( default )

                  //this._input_box.configure_editor(edit_mode);
                  this.$.input.setMode(edit_mode);

                  this._r_idx += 1; // 't'
                  break;

                case 'd': // ... [,<length>,<pattern>] ...

                  if ( ',' === this._message[this._r_idx] ) {
                    this._r_idx++;
                    w = this._getDouble();
                    //this._input_box.configure_editor(edit_mode, this._message.substring(this._r_idx, this._r_idx + w));
                    this.$.input.setMode(edit_mode);
                    this._r_idx += w;
                  } else {
                    //this._input_box.configure_editor(edit_mode);
                    this.$.input.setMode(edit_mode);
                  }
                  this._r_idx++;
                  break;

                case 'n':  // ... Number [,<length>,<pattern>] ...

                  if ( ',' === this._message[this._r_idx] ) {
                      this._r_idx++;
                      w = this._getDouble();
                      //this._input_box.configure_editor(edit_mode, this._message.substring(this._r_idx, this._r_idx + w));
                      this.$.input.setMode(edit_mode);
                      this._r_idx += w;
                  } else {
                    //this._input_box.configure_editor(edit_mode);
                    this.$.input.setMode(edit_mode);
                  }
                  this._r_idx++;
                  break;

                case 'c':  // 'c'<version>,<empty_line><length>,<field_id>,<length>,<display_field>{,<length>,<field>}[,<length>,<list json>] Simple combo  client side
                  var version = this._getDouble();
                  console.log("Combo List Version " + version);

                  // empty_line: 0 or 1
                  // console.log("Combo Empty Line: " + this._getDouble());
                  var nullable_list = this._getDouble();
                  // fields '}'
                  var fields = [];
                  w = this._getDouble();
                  if ( w > 2 ) {
                    var tmp = this._message.substring(this._r_idx + 1, this._r_idx + w - 1);
                    fields = tmp.split(',');
                    //console.log("Combo FIELDS: " + fields);
                  }
                  this._r_idx += w + 1;

                  // list id
                  w  = this._getDouble();
                  t2 = this._message.substring(this._r_idx, this._r_idx + w);
                  //console.log("Combo list id: " + t2);
                  this._r_idx += w + 1;

                  // sub document params <length>,<uri>,<length>,<jrxml>
                  w = this._getDouble();
                  if ( w == 0 ) {
                    this._sub_document_uri = undefined;
                  } else {
                    this._sub_document_uri = this._message.substring(this._r_idx, this._r_idx + w);
                  }
                  this._r_idx += w + 1;
                  w = this._getDouble();
                  if ( w == 0 ) {
                    this._sub_document_jrxml = undefined;
                  } else {
                    this._sub_document_jrxml = this._message.substring(this._r_idx, this._r_idx + w);
                  }
                  this._r_idx += w;

                  if ( ',' === this._message[this._r_idx] ) {
                    this._r_idx++;
                    // list [optional]
                    w  = this._getDouble();
                    t3 = this._message.substring(this._r_idx, this._r_idx + w);
                    //console.log("Combo JSON: " + t3);
                    this._r_idx += w;
                  } else {
                    t3 = undefined;
                  }

                  //this._input_box.configure_editor(edit_mode, this._sub_document_jrxml, nullable_list);
                  this.$.input.setMode(edit_mode);
                  this.$.input.setDisplayFields(fields);
                  if ( version === 2 ) {
                    // ... outra coisa ...
                    console.log("Combo Query:" + t3);
                  } else {
                    this.$.input.setModelFromJson(t2,t3);
                  }
                  this._r_idx++;
                  break;

                case 'R': // 'R'<idx>,<length>,<variable>,<lenght>,<value_array>

                  x  = this._getDouble();                                      // -1 for parameters, row index for fields
                  w  = this._getDouble();
                  t1 =this._message.substring(this._r_idx, this._r_idx + w);   // variable name, parameter ou field
                  this._r_idx += w + 1; // + 1 -> ','
                  w  = this._getDouble();
                  t2 =this._message.substring(this._r_idx, this._r_idx + w);   // Array with current and possible values
                  this._r_idx += w + 1; // +1 -> ';''
                  console.log(' Prepare radio button: idx=' + x + ', var=' + t1 + ', values=' + JSON.parse(t2));
                  //this._input_box.configure_editor(edit_mode);
                  this.$.input.setMode(edit_mode);
                  break;

                case 'C': // 'C'[,<length>,<uri>,<length>,<jrxml>] Combos server side, IVAS, Rubricas, Centros de Custo

                  if ( ',' === this._message[this._r_idx] ) {
                    this._r_idx++;
                    w = this._getDouble();
                    this._sub_document_uri = this._message.substring(this._r_idx, this._r_idx + w);
                    this._r_idx += w;
                    this._r_idx++; // ','
                    w = this._getDouble();
                    this._sub_document_jrxml = this._message.substring(this._r_idx, this._r_idx + w);
                    this._r_idx += w;
                  }
                  //this._input_box.configure_editor(edit_mode, this._sub_document_jrxml);
                  this.$.input.setMode(edit_mode);

                  this._r_idx += 1;
                  break;

                case 'l':  // 'l' Combo that searches on a ledger tree

                  //this._input_box.configure_editor(edit_mode);
                  this.$.input.setMode(edit_mode);


                  var fields = [];
                  w = this._getDouble();
                  if ( w > 2 ) {
                    var tmp = this._message.substring(this._r_idx + 1, this._r_idx + w - 1);
                    fields = tmp.split(',');

                    //console.log("Combo FIELDS: " + fields);
                  }
                  this.$.input.setDisplayFields(fields);
                  this._r_idx += w + 1;
                  break;

                default:
                  break;
                }

              } else if ( option === 'p' ) { // Prepare editor defines the bounding box

                x = this._getDouble() / s;
                y = this._getDouble() / s;
                w = this._getDouble() / s;
                h = this._getDouble() / s;
                this._inputBoxDrawString = this._message.substring(this._r_idx);
                this.$.input.alignPosition(x, y, w, h);

                //this._input_box.prepare_editor(x, y, w, h, this._message.substring(this._r_idx));

                this._update_context_menu(y + h / 2);

                return; // The rest of the draw string is just stored it will be painted by the editor

              } else if ( option === 's' ) { // ... start editor ...

                x = this._getDouble();
                y = this._getDouble();
                h = this._getDouble();
                this._focused_band_id = this._getDouble();

                if ( '{' === this._message[this._r_idx] ) {
                  this._r_idx += 1; // '{'

                  w = this._getDouble();
                  var id = this._message.substring(this._r_idx, this._r_idx + w);
                  this._r_idx += w + 1;

                  w = this._getDouble();
                  var value = this._message.substring(this._r_idx, this._r_idx + w);
                  this._r_idx += w + 1; // +1 -> '}'

                  //console.log("Start Combo: " + id + ", " + value);

                  //this._input_box._start_editor_handler(x, y, h, id);
                  this.$.input.setValue(id);

                } else {
                  w = this._getDouble();

                  //this._input_box._start_editor_handler(x, y, h, this._message.substring(this._r_idx, this._r_idx + w));
                  this.$.input.setValue(this._message.substring(this._r_idx, this._r_idx + w));
                  this._r_idx += w;
                }

                // Paint the input box and align the HTML control style
                this._save_paint_context();
                this._paint_string(this._inputBoxDrawString);
                this._restore_paint_context();
                this.$.input.alignStyle(x,y,h);
                this.$.input.focus();
                this._r_idx += 1;

                // TODO if ( false == this._band_tearing ) {
                  this._adjust_scroll();
                //}

              } else if ( option === 'u' ) {  // ... update editor ...

                w  = this._getDouble();
                t1 = this._message.substring(this._r_idx, this._r_idx + w);
                this._r_idx += w;
                if ( this._message[this._r_idx] !== ';' ) {
                  this._r_idx += 1;
                  w  = this._getDouble();
                  t2 = this._message.substring(this._r_idx, this._r_idx + w);
                  this._r_idx += w;

                  if ( this._message[this._r_idx] !== ';' ) {
                    this._r_idx += 1;
                    w  = this._getDouble();
                    t3 = this._message.substring(this._r_idx, this._r_idx + w);
                    this._r_idx += w + 1;
                  } else {
                    this._r_idx += 1;
                    t3 = '';
                  }
                } else {
                  this._r_idx += 1;
                  t2 = '';
                  t3 = '';
                }
                console.log("=== update: t1='" + t1 + "' t2='" + t2 + "' t3='" + t3 + "'");

                if ( ';' !== this._message[this._r_idx - 1] ) {
                  w = this._getDouble();

                  var json = this._message.substring(this._r_idx, this._r_idx + w);

                  this.$.input.setModelFromJson(undefined, json);
                  this.$.input.autoSizeOverlay(this.$.input.style.width);

                  //console.log("JSON: " + json);

                  this._r_idx += w + 1;
                } else {
                  this.$.input.setModelFromJson(undefined, '[]');
                  this.$.input.autoSizeOverlay(this.$.input.style.width);
                }

                //if ( this._input_box._enabled ) {
                  //this._input_box._update_editor_handler(t1, t2, t3);
                //}

              } else if ( option === 'f' ) { // ... finish or stop the editor ...

                //if ( this._input_box._enabled ) {
                //  this._input_box._stop_editor_handler();
                //}
                this._inputBoxDrawString = undefined;
                this._r_idx += 1;

                // ... clear the sub document variables ...
                this._sub_document_uri   = undefined;
                this._sub_document_jrxml = undefined;
              } else if ( option == 'b' ) {

                this._r_idx += 1;

                var tmp_stroke_style = this._ctx.strokeStyle;
                this._ctx.strokeStyle = "#FF0000";
                this._ctx.strokeRect(this._getDouble(), this._getDouble(), this._getDouble(), this._getDouble());
                this._ctx.strokeStyle = tmp_stroke_style;

              } else if ( option === 'h' ) { // ... tootip hint ...

                x  = this._getDouble() / s;
                y  = this._getDouble() / s;
                w  = this._getDouble() / s;
                h  = this._getDouble() / s;
                w  = this._getDouble();
                t1 = this._message.substring(this._r_idx, this._r_idx + w);
                this.$.input.serverTooltipUpdate(x, y, w, h, t1.toUpperCase());
                this._r_idx += w + 1;
              }

              this._ctx.restore();
              break;

            /*
             * === 'T' Draw text
             */
            case 'T':

              option = this._message[this._r_idx];
              if ( option === 'S' || option === 'F' || option === 'P' ) {
                this._r_idx++;
              } else {
                option = 'F';
              }
              x = this._getDouble();
              y = this._getDouble();
              w = this._getDouble();
              this._t = this._message.substring(this._r_idx, this._r_idx + w);
              this._r_idx += w;
              if ( this._message[this._r_idx] == ',') {
                this._r_idx++;
                option_num = this._getDouble();

                switch (option) {
                  case 'F':
                    this._ctx.fillStyle = this._text_color;
                    if ( do_paint ) {
                      this._ctx.fillText(this._t, x, y, option_num);
                    }
                    break;

                  case 'S':
                    if ( do_paint ) {
                      this._ctx.strokeText(this._t, x, y, option_num);
                    }
                    break;

                  case 'P':
                    this._ctx.fillStyle = this._text_color;
                    if ( do_paint ) {
                      this._ctx.fillText(this._t, x, y, option_num);
                      this._ctx.strokeText(this._t, x, y, option_num);
                    }
                    break;
                }

              } else {
                this._r_idx++;
                switch (option) {
                  case 'F':
                    this._ctx.fillStyle = this._text_color;
                    if ( do_paint ) {
                      this._ctx.fillText(this._t, x, y);
                    }
                    break;

                  case 'S':
                    if ( do_paint ) {
                      this._ctx.strokeText(this._t, x, y);
                    }
                    break;

                  case 'P':
                    this._ctx.fillStyle = this._text_color;
                    if ( do_paint ) {
                      this._ctx.fillText(this._t, x, y);
                      this._ctx.strokeText(this._t, x, y);
                    }
                    break;
                }
              }
              this._ctx.fillStyle = this._fill_color;
              break;

            /*
             * === 'P' Path TODO
             */
            case 'P':
              break;

            /*
             * === 'C' Fill color
             */
            case 'C':

              this._fill_color = "#" + this._message.substring(this._r_idx, this._r_idx + 6);
              this._r_idx += 7;
              break;

            /*
             * === 'c' Text fill color
             */
            case 'c':

              this._text_color = "#" + this._message.substring(this._r_idx, this._r_idx + 6);
              this._r_idx += 7;
              break;

            /*
             * === 'w' Stroke Width w<width>;
             */
            case 'w':

              w = this._getDouble();
              if ( w <= 1 ) {
                w = this._ratio;
              }
              this._ctx.lineWidth = w;
              break;

            /*
             * === 's' Stroke Color TODO alfa support ??
             */
            case 's':

              this._ctx.strokeStyle = "#" + this._message.substring(this._r_idx, this._r_idx + 6);
              this._r_idx += 7;
              break;

            /*
             * === 'p' Line pattern TODO
             */
            case 'p':
              break;

            /*
             * === 'E' Ellipse
             */
            case 'E':

              option = this._message[this._r_idx];
              if ( option == 'S' || option == 'F' || option == 'P' ) {
                this._r_idx++;
              } else {
                option = 'F';
              }
              x = this._getDouble();
              y = this._getDouble();
              w = this._getDouble();
              h = this._getDouble();
              var ox = (w / 2) * this._KAPPA,
                  oy = (h / 2) * this._KAPPA,
                  xe = x + w,
                  ye = y + h,
                  xm = x + w / 2,
                  ym = y + h / 2;

              if ( do_paint ) {
                this._ctx.beginPath();
                this._ctx.moveTo(x, ym);
                this._ctx.bezierCurveTo(x       , ym - oy , xm - ox , y       , xm, y);
                this._ctx.bezierCurveTo(xm + ox , y       , xe      , ym - oy , xe, ym);
                this._ctx.bezierCurveTo(xe      , ym + oy , xm + ox , ye      , xm, ye);
                this._ctx.bezierCurveTo(xm - ox , ye      , x       , ym + oy , x , ym);
              }
              switch (option) {
                case 'F':
                  this._ctx.fillStyle = this._fill_color;
                  if ( do_paint ) {
                    this._ctx.fill();
                  }
                  break;

                case 'S':
                  if ( do_paint ) {
                    this._ctx.stroke();
                  }
                  break;

                case 'P':
                  this._ctx.fillStyle = this._fill_color;
                  if ( do_paint ) {
                    this._ctx.fill();
                    this._ctx.stroke();
                  }
                  break;
              }

              break;

            /*
             * === 'I' Image : I<url_chars_count>,<url>,<x>,<y>,<w>,<h>
             * === 'I' Image : I<url_chars_count>,<url>,<x>,<y>,<w>,<h>,<sx>,<sy>,<sw>,<sh>
             */
            case 'I':

              w = this._getDouble();
              this._t = this._message.substring(this._r_idx, this._r_idx + w);
              this._r_idx += w + 1;

              x = this._getDouble();
              y = this._getDouble();
              w = this._getDouble();
              h = this._getDouble();
              if ( this._message[this._r_idx - 1] != ';' ) {
                sx = this._getDouble();
                sy = this._getDouble();
                sw = this._getDouble();
                sh = this._getDouble();
              } else {
                sx = -1.0;
              }
              var img = this._images[this._t];
              if ( img === undefined ) {
                var self = this;
                img = new Image();
                img.onload = function() {
                  self.restart_redraw_timer();
                }
                img.onerror = function() {
                  self._images[this.src] = undefined;
                }
                img.src = this._t;
                this._images[this._t] = img;
              }
              if ( img.complete && typeof img.naturalWidth !== undefined && img.naturalWidth !== 0 ) {
                try {
                  if ( sx !== -1.0 ) {
                    this._ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
                  } else {
                    this._ctx.drawImage(img, x, y, w, h);
                    //console.log("=== Draw image @" + x + "," + y + " " + w + "x" + h);
                    //this._ctx.drawImage(this.step_down(img, w,h), x, y, w, h);
                  }
                } catch (a_err) {
                  // Keep the faulty image in the cache to avoid bombarding the server with broken requests
                }
              }
              break;

            /*
             * === 'F' Set font name F<len>,<font name>;
             */
            case 'F':

              w = this._getDouble();
              this._t = this._message.substring(this._r_idx, this._r_idx + w);
              this._r_idx += w + 1;
              this._font_spec[this._FONT_NAME_INDEX] = this._t;
              this._ctx.font = this._font_spec.join('');
              break;

            /*
             * === 'f'  Set font flag <size>, font mask <flag_mask>,f<size>
             *  |  'fm' Set font metrics <flag_mask>,f<size>,<fFlags>, <fTop>, <fAscent>, <fDescent>, <fBottom>, <fLeading>, <fAvgCharWidth>, <  fMaxCharWidth>, <fUnderlineThickness>, fUnderlinePosition>;
             */
            case 'f':
              if ( 'm' == this._message[this._r_idx] ) {
                  this._r_idx++;
                  /*this._input_box._f_flags               = */this._getDouble();
                  /*this._input_box._f_top                 = */this._getDouble();
                  /*this._input_box._f_ascent              = */this._getDouble();
                  /*this._input_box._f_descent             = */this._getDouble();
                  /*this._input_box._f_bottom              = */this._getDouble();
                  /*this._input_box._f_leading             = */this._getDouble();
                  /*this._input_box._f_avg_char_width      = */this._getDouble();
                  /*this._input_box._f_max_char_width      = */this._getDouble();
                  /*this._input_box._f_underline_thickness = */this._getDouble();
                  /*this._input_box._f_underline_position  = */this._getDouble();
              } else {
                  this._font_mask = this._getDouble();
                  this._font_spec[this._SIZE_INDEX]   = Math.round(this._getDouble());
                  this._font_spec[this._BOLD_INDEX]   = (this._font_mask & this._BOLD_MASK)   ? 'bold '   : '';
                  this._font_spec[this._ITALIC_INDEX] = (this._font_mask & this._ITALIC_MASK) ? 'italic ' : '';
                  this._ctx.font = this._font_spec.join('');
              }
              break;

            /*
             * === 'X' Set translation X<x>,<y>;
             */
            case 'X': //=== Legacy command, deprecated

              this._getDouble();
              this._getDouble();
              break;

            /*
             * === 't' Apply transform
             */
            case 't':

              switch (this._message[this._r_idx++]) {
                case 'r':
                  this._ctx.translate(this._getDouble(), this._getDouble());
                  this._ctx.rotate(this._getDouble());
                  break;
                case 'c':
                  this._ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this._r_idx++;
                  break;
              }
              break;

            /*
             * === 'k'  Set canvas properties
             *  |- 'kp' Set page params - kp<width>,<height>,<page_number>,<page_count>;
             *  |- 'kg' Set grid params - kg<major>,<minor>; (use kg0,0; to disable grid)
             */
            case 'k': //===

              option = this._message[this._r_idx++];
              if ( 'g' === option ) {
                this._grid_major = this._getDouble();
                this._grid_minor = this._getDouble();
              } else if ( 'p' === option ) {
                var new_page_number = this._getDouble();
                var new_page_count = this._getDouble();

                if ( this._page_number != new_page_number || this._page_count != new_page_count ) {
                  if ( this.on_page_properties_changed != undefined ) {
                    this.on_page_properties_changed(this._page_width, this._page_height, new_page_number, new_page_count);
                  }
                  this._page_count  = new_page_count;
                  this._page_number = new_page_number;
                }
              }
              break;
          }
          if ( this._message[this._r_idx - 1] != ';' ) {
            console.log("command is not terminated ...");
          }
        }
      },

      /**
       * @brief Adjust the canvas dimension taking into account the pixel ratio
       *
       * Also calculates the scale the server should use in _sx and _sy
       */
      _setup_scale: function () {
        this._canvas.width  = this._canvas_width  * this._ratio;
        this._canvas.height = this._canvas_height * this._ratio;
        this._canvas.style.width  = this._canvas_width  + 'px';
        this._canvas.style.height = this._canvas_height + 'px';
        this._sx = this._canvas.width  / this._page_width;
        this._sy = this._canvas.height / this._page_height;
        this.clear_page();
      },

      _binary_find_band_by_id: function (a_id) {

        if ( this._bands !== undefined && this._bands.length > 0 ) {
          var mid;
          var min = 0.0;
          var max = this._bands.length - 1;

          while ( min <= max ) {
            mid = Math.floor((min + max) / 2.0);

            if ( this._bands[mid]._id === a_id ) {

              return mid; // found!

            } else if ( this._bands[mid]._id < a_id ) {
              min = mid + 1;
            } else {
              max = mid - 1;
            }
          }
        }
        return -1; // Not found!
      },

      /**
       * @start the redraw timer will redraw the page after a timeout
       */
      _restart_redraw_timer: function (a_time_in_ms) {
        var timeout = a_time_in_ms !== undefined ? a_time_in_ms : 300;

        if ( window[this._redraw_timer_key] !== undefined ) {
          window.clearTimeout(window[this._redraw_timer_key]);
          window[this._redraw_timer_key] = undefined;
        }
        window[this._redraw_timer_key] = setInterval(this._create_redraw_timer_handler(this), timeout);
      },

      /**
       * @brief Resets the deferred repaint timer
       */
      _reset_redraw_timer: function () {

        if ( window[this._redraw_timer_key] !== undefined ) {
          window.clearTimeout(window[this._redraw_timer_key]);
          window[this._redraw_timer_key] = undefined;
        }
      },

      /**
       * @brief Create the handler for the mouse over time-out
       *
       * @param a_self The tooltip helper instance
       * @return the handler function
       */
      _create_redraw_timer_handler: function (a_self) {
        return function () {
          a_self._repaint_page();
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                            ~~~ Widget management ~~~                                  */
      /*                                                                                       */
      /*****************************************************************************************/

      _adjust_scroll: function () {

        var v_l  = undefined;
        var v_t  = undefined;
        var v_w  = undefined;
        var v_h  = undefined;
        var sb_w = 0;
        var sb_h = 0;

        if ( undefined !== this._scroll_container_ ) {
          v_l  = this._scroll_container_.scrollLeft;
          v_t  = this._scroll_container_.scrollTop;
          v_w  = this._scroll_container_.offsetWidth;
          v_h  = this._scroll_container_.offsetHeight;
          sb_w = this._scroll_container_.offsetWidth - this._scroll_container_.clientWidth;
          sb_h = this._scroll_container_.offsetHeight - this._scroll_container_.clientHeight;
        } else {
          v_l  = ( (window.pageXOffset || document.scrollLeft) - ( document.clientLeft || 0.0 ) ) || 0.0;
          v_t  = ( (window.pageYOffset || document.scrollTop)  - ( document.clientTop  || 0.0 ) ) || 0.0;
          v_w  = window.innerWidth;
          v_h  = window.innerHeight;
          sb_w = ( window.innerWidth - document.documentElement.clientWidth ) || 0;
          sb_h = ( window.innerHeight - document.documentElement.clientHeight ) || 0
        }

        /*var i_w  = ( this._input_box._bb_w / this._ratio );
        var i_h  = ( this._input_box._bb_h / this._ratio );
        var i_l  = ( this._input_box._bb_x / this._ratio );
        var i_t  = ( this._input_box._bb_y / this._ratio );

        // horizontal
        var s_x  = undefined
        if ( i_w < ( v_w - sb_w ) ) {
          var x_t  = 4.0;
          var i_r  = i_l + i_w;
          var v_ll = v_l;
          if ( undefined === this._scroll_container_ ) {
             v_ll -= this._canvas.offsetLeft;
          }
          var v_rl = v_l + v_w - sb_w;
          if ( undefined === this._scroll_container_ ) {
             v_rl -= this._canvas.offsetLeft;
          }
          if ( i_l < v_ll ) {
            s_x = v_l - ( v_ll - i_l ) - x_t;
          } else if ( i_r > v_rl ) {
            s_x = v_l + ( i_r - v_rl ) + x_t;
          }
        }

        // vertical
        var s_y  = undefined
        if ( ( v_h - sb_h ) > i_h ) {
          var y_t  = 4.0;
          var i_b  = i_t + i_h;
          var v_bl = v_t + v_h - sb_h;
          if ( undefined === this._scroll_container_ ) {
            v_bl -= this._canvas.offsetTop;
          }
          var v_tl = v_t;
          if ( undefined === this._scroll_container_ ) {
            v_tl -= - this._canvas.offsetTop;
          }
          if ( i_t < v_tl ) {
            s_y = v_t - ( v_tl - i_t ) - y_t;
          } else if ( i_b > v_bl ) {
            s_y = v_t + ( i_b - v_bl ) + y_t;
          }
        }

        // adjust scroll?
        if ( undefined !== s_x || undefined !== s_y ) {
          if ( undefined !== this._scroll_container_ ) {
            this._scroll_container_.scrollLeft = s_x || v_l;
            this._scroll_container_.scrollTop  = s_y || v_t;
          } else {
            window.scrollTo(s_x || v_l, s_y || v_t);
          }
        }

        // adjust input 'helper'?
        if ( undefined !== this._input_box._html_input ) {
          this._input_box._html_input.style.left   = "0px";
          this._input_box._html_input.style.top    = "0px";
          this._input_box._html_input.style.width  = i_w + "px";
          this._input_box._html_input.style.height = i_h + "px";
        }*/

      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                           ~~~ Context menu handling ~~~                               */
      /*                                                                                       */
      /*****************************************************************************************/

      _addDocumentLine: function (a_src_widget) {
        if ( this._context_menu_idx !== - 1) {
          this.send_command('document add band "' + this._bands[this._context_menu_idx]._type +
                                    '" ' + this._bands[this._context_menu_idx]._id + ';',
                            function (a_msg) {
                              if ( a_msg === 'S:ok:parser' ) {
                                // Start animation
                              } else if ( a_msg.indexOf('S:ok:band add') === 0 ) {
                                // All done
                              } else {
                                // error
                                console.log('=== add_line failed: a_msg');
                              }
                            });
        }
      },

      _removeDocumentLine: function (a_src_widget) {
        if ( this._context_menu_idx !== - 1) {
          this.send_command('document remove band "' + this._bands[this._context_menu_idx]._type +
                                    '" ' + this._bands[this._context_menu_idx]._id + ';',
                            function (a_msg) {
                              if ( a_msg === 'S:ok:parser' ) {
                                // Start animation
                              } else if ( a_msg.indexOf('S:ok:band remove') === 0 ) {
                                // All done
                              } else {
                                // error
                                console.log('=== remove_line failed: a_msg');
                              }
                            });
        }
      },

      _binary_find_band_by_y: function (a_y) {

        if ( this._bands !== undefined && this._bands.length > 0 ) {
          var mid;
          var min = 0.0;
          var max = this._bands.length - 1;

          while ( min <= max ) {
            mid = Math.floor((min + max) / 2.0);

            if (   this._bands[mid]._type != 'Background'
                && a_y >= this._bands[mid]._ty
                && a_y <= (this._bands[mid]._ty + this._bands[mid]._height) ) {

              return mid; // found!

            } else if ( this._bands[mid]._ty < a_y ) {
              min = mid + 1;
            } else {
              max = mid - 1;
            }
          }
        }
        return -1; // Not found!
      },

      _update_context_menu: function (a_y) {

        if ( this._edition === false ) {
          this._deactivateLineContextMenu();
          return;
        } else {
          var idx = this._binary_find_band_by_y(a_y);

          if ( idx != -1 ) {
            if ( this._bands[idx]._type === 'DT' && this._bands[idx].editable_ == true ) {
              if ( this._context_menu_idx == idx ) {
                return;
              }
              if ( this._context_menu_idx !== -1 ) {
                this._deactivateLineContextMenu(this._bands[this._context_menu_idx]);
                this._context_menu_idx = -1;
              }
              this._context_menu_idx = idx;
              this._activateLineContextMenu(this._bands[this._context_menu_idx]);

            } else {
              if ( this._context_menu_idx !== -1 ) {
                this._deactivateLineContextMenu(this._bands[this._context_menu_idx]);
                this._context_menu_idx = -1;
              }
            }
          } else {
            if ( this._context_menu_idx !== -1 ) {
              if ( this._bands !== undefined ) {
                this._deactivateLineContextMenu(this._bands[this._context_menu_idx]);
              }
              this._context_menu_idx = -1;
            }
          }
        }
      },

      _activateLineContextMenu: function (a_band) {

        var button_y = a_band._ty + a_band._height / 2 - (this._BTN_SIZE * this._ratio) / 2;
        var button_x = (this._page_width - this._right_margin) * this._sx;

        this.$.line_add_button.style.left = (button_x / this._ratio ) + 'px';
        this.$.line_add_button.style.top  = (button_y / this._ratio ) + 'px';
        button_x += this._BTN_SIZE * this._ratio * 0.9;
        this.$.line_del_button.style.left = (button_x / this._ratio ) + 'px';
        this.$.line_del_button.style.top  = (button_y / this._ratio ) + 'px';

        if ( this._edition /*&& this.is_focused()*/ ) {
          this.$.line_add_button.style.display = 'inline-block';
          this.$.line_del_button.style.display = 'inline-block';
        }
      },

      _deactivateLineContextMenu: function (a_band) {
        this.$.line_add_button.style.display = 'none';
        this.$.line_del_button.style.display = 'none';
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                                ~~~ Band tearing ~~~                                   */
      /*                                                                                       */
      /*****************************************************************************************/

      on_edit_subdocument: function (a_src_widget) {

        //this._tear_paper(a_src_widget._bb_y + a_src_widget._bb_h + 5, 200 * this._ratio, 1000);
        this.open_document(this._sub_document_jrxml,
                           this._locale,
                           this._prefix,
                           this._schema,
                           this._table_prefix,
                           true,
                           true,
                           function (a_epaper, a_page_width, a_page_height) {
                              a_epaper.load_document(a_epaper._sub_document_uri, undefined, true, true, function(a_epaper) {
                                console.log("=== Sub document loaded YUPPIIII!!!!");
                            });
                          });
      },

      on_close_subdocument: function () {
        this.close_document();
        //this.glue_paper();
      },

      on_add_entity: function (a_src_widget) {
        console.log("*** ADD entity");
      },

      /**
       * @brief Cover the whole canvas with a white transparent overlay
       */
      _washout_canvas: function () {
        var saved_fill = this._ctx.fillStyle;
        this._ctx.fillStyle = 'rgba(255,255,255,0.5)';
        this._ctx.fillRect(0,0, this._canvas.width, this._canvas.height);
        this._ctx.fillStyle = saved_fill;
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                               ~~~ Websocket handlers ~~~                              */
      /*                                                                                       */
      /*****************************************************************************************/

      send_command: function (a_message, a_callback) {
        this._request_callback = a_callback || this.default_ws_handler;
        this._socket.send_command(a_message, this._request_callback);
      },

      disconnect: function () {
        this._socket.disconnect();
      },

      // default websocket handler
      default_ws_handler: function (a_msg) {

      },

      on_socket_message: function (a_message) {
        switch (a_message.data[0]) {
          case 'S':
            this._request_callback(a_message.data);
            break;

          case 'N':
            if ( this._listener !== undefined ) {
              this._listener.on_notification_received(a_message.data.substring(2));
            }
            break;

          case 'E':

            this._r_idx   = 1;
            this._message = a_message.data;

            var w = this._getDouble();
            var k = this._message.substring(this._r_idx, this._r_idx + w);
            this._r_idx += w + 1; // +1 -> ','

                w = this._getDouble();
            var t = this._message.substring(this._r_idx, this._r_idx + w);
            this._r_idx += w + 1; // +1 -> ','

                w = this._getDouble();
            var m = this._message.substring(this._r_idx, this._r_idx + w);
            this._r_idx += w + 1; // +1 -> ','

            if ( this._message[this._r_idx - 1] != ';' ) {
              console.log("command is not terminated ...");
            }

            if ( undefined !== this._listener && undefined !== this._listener.on_error_received ) {
                this._listener.on_error_received(t, m);
            }
            break;

          case 'D':
            this._on_paint_message(a_message.data);
            break;

          default:
            // ignore
            break;
        }
      },

      on_socket_open: function (a_message) {
        this._is_socket_open = true;

        if ( this._listener !== undefined ) {
          this._listener.on_socket_open();
        }
      },

      on_socket_close: function (a_message) {
        this._is_socket_open = false;

        if ( this._listener !== undefined ) {
          this._listener.on_socket_close();
        }
      },

      is_socket_open: function() {
        return this._is_socket_open;
      },


    });
  </script>
</dom-module>
